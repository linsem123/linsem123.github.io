<!DOCTYPE html>
<html lang="zh-CN">

  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="董沅鑫, yuanxin.me@gmail.com">
  
  
  
  <title>JavaScript设计模式 | Aloha,I&#39;m Derek</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="编程,学习,js,">
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="come on">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">

  <script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>

  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

</head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">VEGETABLE</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a href="/" target="_self">
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a href="/archives/" target="_self">
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a href="/categories/" target="_self">
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a href="/tags/" target="_self">
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a href="/friends/" target="_self">
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a href="/about/" target="_self">
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path>
          
            <a href="javascript:void(0);" v-else>抓到我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a href="https://github.com/angryreid" target="_blank">
                    Github
                  </a>
                </li>
              
                <li>
                  <a href="https://www.jianshu.com/u/7af28c5c8baa" target="_blank">
                    jianshu
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>JavaScript设计模式</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2019-10-21
    </span>
    
      <span>
        分类 : 
          <a href="/categories/编程/">
            编程
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="JavaScript设计模式"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h1 id="《JavaScript设计模式》"><a href="#《JavaScript设计模式》" class="headerlink" title="《JavaScript设计模式》"></a>《JavaScript设计模式》</h1><h3 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义： 保证一个类仅有一个实例，并提供访问此实例的全局访问点。</span><br><span class="line"> * 用途：如果一个类负责连接数据库的线程池，日志记录逻辑等等，此时需要单例模式来保证对象不被重复创建，以达到降低开销的目的。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const Singleton = function() &#123;&#125;;</span><br><span class="line">Singleton.getInstance = (function() &#123;</span><br><span class="line">  // 由于es6没有静态类型，使用闭包；函数外部无法访问 instacne</span><br><span class="line">  let instance = null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    if (!instance) &#123;</span><br><span class="line">      instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let s1 = Singleton.getInstance();</span><br><span class="line">let s2 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">console.log(s1 === s2);</span><br></pre></td></tr></table></figure>
<h3 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义：工厂模式的实质“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例话推迟到子类中进行”，简单来说，就是把new 对象的操作包裹一层，对外提供一个可以根据不同参数创建不同对象的函数。</span><br><span class="line"> * 优点：可以隐藏原始类，方便之后的代码迁移。调用者只需要记住类的代名词即可</span><br><span class="line"> * 缺点：由于多了层封装，会造成类的数目过多，系统复杂度增加。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    console.log(&quot;dog&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    console.log(&quot;cat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    name = name.toLocalLowerCase();</span><br><span class="line">    switch (name) &#123;</span><br><span class="line">      case &quot;dog&quot;:</span><br><span class="line">        return new Dog();</span><br><span class="line">      case &quot;cat&quot;:</span><br><span class="line">        return new Cat();</span><br><span class="line">      default:</span><br><span class="line">        throw TypeError(&quot;class name wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const cat = new Animal(&quot;cat&quot;);</span><br><span class="line">const dog = new Animal(&quot;dog&quot;);</span><br><span class="line">cat.run();</span><br><span class="line">dog.run();</span><br></pre></td></tr></table></figure>
<h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义：抽象工厂模式就是，围绕一个超级工厂类，创建其他工厂类；在围绕工厂类，创建实体类</span><br><span class="line"> * 相比较于传统的工厂模式，它多出了一个超级工厂类</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> // 动物实体类</span><br><span class="line"> class Dog&#123;</span><br><span class="line">   run()&#123;</span><br><span class="line">     console.log(&apos;dog is running&apos;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Cat&#123;</span><br><span class="line">   run()&#123;</span><br><span class="line">     console.log(&apos;cat is running&apos;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 人类实体类</span><br><span class="line">class Male&#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">    console.log(&apos;male is talking&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Female&#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">    console.log(&apos;female is talking&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*********************/</span><br><span class="line">// 工厂类</span><br><span class="line">// 为了更好的约束工厂类，先实现一个接口类</span><br><span class="line">class AbstractFactory&#123;</span><br><span class="line">  getPerson()&#123;</span><br><span class="line">    throw new Error(&apos;子类请实现接口&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAnimal()&#123;</span><br><span class="line">    throw new Error(&apos;子类请实现接口&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接下来，Animal 和 Person 继承这个接口类</span><br><span class="line">class PersonFactory extends AbstractFactory&#123;</span><br><span class="line">  getPerson(person)&#123;</span><br><span class="line">    person = person.toLocaleLowerCase();</span><br><span class="line">    switch(person)&#123;</span><br><span class="line">      case &apos;male&apos;:</span><br><span class="line">        return new Male()</span><br><span class="line">      case &apos;female&apos;:</span><br><span class="line">        return new Female();</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAnimal()&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AnimalFactory extends AbstractFactory&#123;</span><br><span class="line">  getPerson()&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAnimal(animal)&#123;</span><br><span class="line">    animal = animal.toLocaleLowerCase();</span><br><span class="line">    switch(animal)&#123;</span><br><span class="line">      case &apos;cat&apos;:</span><br><span class="line">        return new Cat();</span><br><span class="line">      case &apos;dog&apos;:</span><br><span class="line">        return new Dog();</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实现超级工厂</span><br><span class="line"> */</span><br><span class="line">class Factory&#123;</span><br><span class="line">  constructor(choice)&#123;</span><br><span class="line">    switch(choice)&#123;</span><br><span class="line">      case &apos;person&apos;:</span><br><span class="line">        return new PersonFactory();</span><br><span class="line">      case &apos;animal&apos;:</span><br><span class="line">        return new AnimalFactory();</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试代码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> const pf = new Factory(&apos;person&apos;);</span><br><span class="line"> const male = pf.getPerson(&apos;male&apos;);</span><br><span class="line"> const female = pf.getPerson(&apos;female&apos;);</span><br><span class="line"> male.run();</span><br><span class="line"> female.run();</span><br><span class="line"></span><br><span class="line"> const af = new Factory(&apos;animal&apos;);</span><br><span class="line"> const cat = af.getAnimal(&apos;cat&apos;);</span><br><span class="line"> const dog = af.getAnimal(&apos;dog&apos;);</span><br><span class="line"> cat.run();</span><br><span class="line"> dog.run();</span><br></pre></td></tr></table></figure>
<h3 id="四、享元模式"><a href="#四、享元模式" class="headerlink" title="四、享元模式"></a>四、享元模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 享元模式：运用共享技术来减少创建的对象的数量，从而减少内存占用、提高性能</span><br><span class="line"> * 1. 享元模式提醒我们将一个对象的属性划分为内部和外部状态。</span><br><span class="line"> *  内部状态：可以被对象集共享，通常不会改变。</span><br><span class="line"> *  外部状态；根据应用场景经常改变。</span><br><span class="line"> * 2. 享元模式是利用时间换取空间的优化模式。</span><br><span class="line"> * </span><br><span class="line"> * 应用场景：只要是需要大量创建重复的类的代码块，均可以使用享元模式抽离内部，外部状态，减少重复类的创建。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  对象池</span><br><span class="line">class ObjectPool&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.__pool = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建对象</span><br><span class="line">  create(Obj)&#123;</span><br><span class="line">    return this.__pool.length === 0</span><br><span class="line">    ? new Obj(this) // 对象池中没有空闲对象，则创建一个对象</span><br><span class="line">    : this.__pool.shift(); // 对象池中有空闲对象，直接取出，无需再次创建</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 对象回收</span><br><span class="line">  recover(obj)&#123;</span><br><span class="line">    return this.__pool.push(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 对象池大小</span><br><span class="line">  size()&#123;</span><br><span class="line">    return this.__pool.length;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 模拟文件对象</span><br><span class="line">class File&#123;</span><br><span class="line">  constructor(pool)&#123;</span><br><span class="line">    this.pool = pool;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 模拟下载操作</span><br><span class="line">  download()&#123;</span><br><span class="line">    console.log(`+ 从$&#123;this.src&#125; 开始下载 $&#123;this.name&#125;`);</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      console.log(`- $&#123;this.name&#125; 下载完毕`); // 下载完毕后，将对象重新放入对象池</span><br><span class="line">      this.pool.recover(this);</span><br><span class="line">    &#125;,100) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*** test ***/</span><br><span class="line">let objPool = new ObjectPool(); </span><br><span class="line"></span><br><span class="line">let file1 = objPool.create(File);</span><br><span class="line">file1.name = &apos;文件1&apos;;</span><br><span class="line">file1.src = &apos;https://download1.com&apos;;</span><br><span class="line">file1.download();</span><br><span class="line"></span><br><span class="line">let file2 = objPool.create(File);</span><br><span class="line">file2.name = &apos;文件2&apos;;</span><br><span class="line">file2.src = &apos;www.baidu.com&apos;;</span><br><span class="line">file2.download();</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  let file3 = objPool.create(File);</span><br><span class="line">  file3.src = &apos;文件3&apos;;</span><br><span class="line">  file3.name = &apos;www.jianshu.com&apos;;</span><br><span class="line">  file3.download();</span><br><span class="line">&#125;,200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(`$&#123;&apos;*&apos;.repeat(50)&#125;\n下载了3个文件，但是只创建了$&#123;objPool.size()&#125;个对象`);</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure>
<h3 id="五、代理模式"><a href="#五、代理模式" class="headerlink" title="五、代理模式"></a>五、代理模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代理模式可以避免对一些对象直接的访问，以此为基础，常见的有保护代理和虚拟代理。保护代理可以在代理中直接绝对，对象的访问；虚拟代理可以延迟访问到真正需要的时候，以便节省程序开销。</span><br><span class="line"> * 优点：代理模式有高度解耦，对象保护，易修改等优点。</span><br><span class="line"> * 缺点：通过设置代理访问对象，因此开销会更大，时间也会慢。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> const myImg = &#123;</span><br><span class="line">   setSrc(imgNode, src)&#123;</span><br><span class="line">     imgNode.src = src;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//  利用代理模式实现图片的懒加载</span><br><span class="line">const proxyImg = &#123;</span><br><span class="line">  setSrc(imgNode, src)&#123;</span><br><span class="line">    // 1. 加载占位图片并且将图片放入&lt;img&gt;元素</span><br><span class="line">    myImg.setSrc(imgNode, &apos;./image.png&apos;);</span><br><span class="line">    // 2. 加载真正需要的图片</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">    // 3. 加载完成后，更新&lt;img&gt;元素中的图片</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      myImg.setSrc(imgNode, src)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">let imgNode = document.createElement(&apos;img&apos;),</span><br><span class="line">  img_src = &apos;https://upload-images.jianshu.io/upload_images/5486602-5cab95ba00b272bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&apos;;</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(imgNode);</span><br><span class="line">  proxyImg.setSrc(imgNode,img_src);</span><br></pre></td></tr></table></figure>
<h3 id="六、桥接模式"><a href="#六、桥接模式" class="headerlink" title="六、桥接模式"></a>六、桥接模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 桥接模式：将抽象部分与具体实现部分分离，两者可独立变化，也可以一起工作。</span><br><span class="line"> * 应用场景：在封装开源库的时候，经常会用到这种设计模式。</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  模拟forEach方法</span><br><span class="line">const forEach = (arr, cb) =&gt; &#123;</span><br><span class="line">  if(!Array.isArray(arr)) return;</span><br><span class="line"></span><br><span class="line">  const length = arr.length;</span><br><span class="line">  for(let i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">    cb &amp;&amp; cb(arr[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">let arr = [1,2,3,4,5];</span><br><span class="line">forEach(arr, (el, index) =&gt; &#123;</span><br><span class="line">  console.log(`元素是：$&#123;el&#125;, 位于第$&#123;index&#125;个。`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="七、组合模式"><a href="#七、组合模式" class="headerlink" title="七、组合模式"></a>七、组合模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将对象组合成树形结构，以用来表示“部分-整体结构”</span><br><span class="line"> * 1. 用小的子对象构造更大的父对象，而这些子对象也由更小的子对象构成。</span><br><span class="line"> * 2. 单个对象和组合对象用户暴露的接口具有一致性，而同种接口不同表现形式亦体现了多态性</span><br><span class="line"> * 应用场景：组合模式可以在需要针对“树形结构”进行操作的应用中使用，例如扫描文件夹，渲染网站导航结构等等。</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  文件类</span><br><span class="line">class File&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name || &quot;File&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add()&#123;</span><br><span class="line">    throw new Error(&apos;文件不能添加文件&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  scan()&#123;</span><br><span class="line">    console.log(&apos;扫描文件：&apos; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文件夹类</span><br><span class="line">class Folder&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name || &quot;Folder&quot;;</span><br><span class="line">    this.files = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(file) &#123;</span><br><span class="line">    this.files.push(file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scan() &#123;</span><br><span class="line">    console.log(&apos;扫描文件夹：&apos; + this.name);</span><br><span class="line">    for(let file of this.files)&#123;</span><br><span class="line">      file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">let home = new Folder(&apos;用户根目录&apos;);</span><br><span class="line"></span><br><span class="line">let folder1 = new Folder(&apos;第一个文件夹&apos;);</span><br><span class="line">let folder2 = new Folder(&apos;第二个文件夹&apos;);</span><br><span class="line"></span><br><span class="line">let file1 = new File(&apos;1号文件&apos;);</span><br><span class="line">let file2 = new File(&apos;2号文件&apos;);</span><br><span class="line">let file3 = new File(&apos;3号文件&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">folder1.add(file1);</span><br><span class="line">folder2.add(file2);</span><br><span class="line">folder2.add(file3);</span><br><span class="line">home.add(folder1);</span><br><span class="line">home.add(folder2);</span><br><span class="line"></span><br><span class="line">home.scan();</span><br></pre></td></tr></table></figure>
<h3 id="八、装饰者模式"><a href="#八、装饰者模式" class="headerlink" title="八、装饰者模式"></a>八、装饰者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 装饰者模式：在不改变对象自身的基础上，动态的添加功能代码</span><br><span class="line"> * 应用场景：多用于一开始不确定的对象，或者对象功能经常变动的时候。尤其是在参数校验，参数拦截等场景。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  ES6 的装饰器语法规范只是在”提案阶段“，而且不能装饰普通的函数或箭头函数。</span><br><span class="line">// 装饰器的触发可以在函数运行之前，也可以在函数运行之后</span><br><span class="line">const addDecorator = (fn, before, after) =&gt; &#123;</span><br><span class="line">  let isFn = fn =&gt; typeof fn === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">  if(!isFn(fn)) &#123;</span><br><span class="line">    return () =&gt; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    let result;</span><br><span class="line">    // 按照顺序执行“装饰函数”</span><br><span class="line">    isFn(before) &amp;&amp; before(...args);</span><br><span class="line">    // 保存返回函数结果</span><br><span class="line">    isFn(fn) &amp;&amp; (result = fn(...args));</span><br><span class="line">    isFn(after) &amp;&amp; after(...args);</span><br><span class="line">    // 最后返回结果</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">const beforeHi = (...args) =&gt; &#123;</span><br><span class="line">  console.log(`Before hello, args are $&#123;args&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const hello = (name = &apos;user&apos;) =&gt; &#123;</span><br><span class="line">  console.log(`hello $&#123;name&#125;`);</span><br><span class="line">  return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const afterHi = (...args) =&gt; &#123;</span><br><span class="line">  console.log(`After hello, args are $&#123;args&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(addDecorator(hello,beforeHi,afterHi)());</span><br></pre></td></tr></table></figure>
<h3 id="九、适配器模式"><a href="#九、适配器模式" class="headerlink" title="九、适配器模式"></a>九、适配器模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器模式为多个不兼容接口之前提供 ‘转化器’</span><br><span class="line"> * 它的操作非常简单，检查接口的数据，进行过滤，重组等操作，使得另一接口可以使用数据</span><br><span class="line"> * 应用场景：当数据不符合使用规则，就可以借助这种模式进行格式转化。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const API = &#123;</span><br><span class="line">  qq: () =&gt; (&#123;</span><br><span class="line">    name: &apos;love&apos;,</span><br><span class="line">    author: &apos;tylor swift&apos;,</span><br><span class="line">    f: 1</span><br><span class="line">  &#125;),</span><br><span class="line">  netease: () =&gt; (&#123;</span><br><span class="line">    n: &apos;love&apos;,</span><br><span class="line">    a: &apos;tylor swift&apos;,</span><br><span class="line">    f: false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const adapter = (info = &#123;&#125;) =&gt; (&#123;</span><br><span class="line">  name: info.name || info.n,</span><br><span class="line">  author: info.author|| info.a,</span><br><span class="line">  free: !!info.f</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(adapter(API.qq()));</span><br><span class="line">console.log(adapter(API.netease()));</span><br></pre></td></tr></table></figure>
<h3 id="十、命令模式"><a href="#十、命令模式" class="headerlink" title="十、命令模式"></a>十、命令模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 命令模式：是一种数据驱动的设计模式，它属于行为型模式。</span><br><span class="line"> * 1. 请求以命令的形式包裹在对象中，并传给调用对象。</span><br><span class="line"> * 2. 调用对象寻求可以处理该命令的合适的对象，并把该命令传给相应的对象。</span><br><span class="line"> * 3. 该对象执行命令。</span><br><span class="line"> * </span><br><span class="line"> * 在这三个步骤中，分别有3个主体，发送者，传递者，和执行者。</span><br><span class="line"> * 应用场景：有时候需要向某些对象发送请求，但是又不知道请求的接受者是谁，更不知道被请求的操作是什么。此时，命令模式就是以一种松耦合的方式来设计程序。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  接收到命令，执行相关操作</span><br><span class="line">const MenuBar = &#123;</span><br><span class="line">  refresh() &#123;</span><br><span class="line">    console.log(&quot;刷新菜单页面&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 命令对象，execute方法就是执行相关的命令</span><br><span class="line">const RefreshMenuBarCommand = receiver =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    execute() &#123;</span><br><span class="line">      receiver.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为按钮对象指定对应的对象</span><br><span class="line">const setCommand = (button, command) =&gt; &#123;</span><br><span class="line">  button.onclick = () =&gt; &#123;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">let button = document.querySelector(&apos;button&apos;);</span><br><span class="line">setCommand(button, refreshMenuBarCommand)</span><br></pre></td></tr></table></figure>
<h3 id="十一、备忘录模式"><a href="#十一、备忘录模式" class="headerlink" title="十一、备忘录模式"></a>十一、备忘录模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 备忘录模式：属于行为模式，保存某个状态，并且在需要的时候就直接获取，而不是重复计算</span><br><span class="line"> * 注意：备忘录模式实现，不能破坏原始封装，也就是说，能拿到内部状态，将其保存在外部。</span><br><span class="line"> * 应用场景：数据缓存呢</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> const fetchData = (() =&gt; &#123;</span><br><span class="line">  //  备忘录/缓存</span><br><span class="line">  const cache = &#123;&#125;;</span><br><span class="line">   return page =&gt; </span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line">      // 如果页面数据已经被缓存，直接推出</span><br><span class="line">      if(page in cache)&#123;</span><br><span class="line">        return resolve(cache[page])</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 否则，异步请求页面数据</span><br><span class="line">      // 模拟异步数据</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        cache[page] = `内容是$&#123;page&#125;`;</span><br><span class="line">        resolve(cache[page])</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)();</span><br><span class="line"></span><br><span class="line">//  test</span><br><span class="line">const run = async () =&gt; &#123;</span><br><span class="line">  let start = new Date().getTime(),</span><br><span class="line">    now;</span><br><span class="line">    // 第一次；没有缓存</span><br><span class="line">    await fetchData(1).then(res =&gt; &#123;</span><br><span class="line">      console.log(&apos;res:&apos; + res);</span><br><span class="line">    &#125;);</span><br><span class="line">    now = new Date().getTime();</span><br><span class="line">    console.log(`没有缓存，耗时$&#123;now - start&#125;ms`);</span><br><span class="line"></span><br><span class="line">    // 第二次：有缓存，有备忘录</span><br><span class="line">    start = now;</span><br><span class="line">    await fetchData(1).then(res =&gt; &#123;</span><br><span class="line">      console.log(&apos;res:&apos; + res);</span><br><span class="line">    &#125;);</span><br><span class="line">    now = new Date().getTime();</span><br><span class="line">    console.log(`有缓存，耗时$&#123;now - start&#125;ms`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>
<h3 id="十二、模板模式"><a href="#十二、模板模式" class="headerlink" title="十二、模板模式"></a>十二、模板模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模板模式：抽象父类定义了子类需要重写的相关方法，而这些方法，仍然是通过父类方法调用的。</span><br><span class="line"> * 注意：父类定义接口方法，子类方法的调用受父类控制。</span><br><span class="line"> * 应用场景：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    //  this 指向实例</span><br><span class="line">    this.live = () =&gt; &#123;</span><br><span class="line">      this.eat();</span><br><span class="line">      this.sleep();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    throw new Error(&apos;模板类方法必须被重写&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep() &#123;</span><br><span class="line">    throw new Error(&quot;模板类方法必须被重写&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  constructor(...args)&#123;</span><br><span class="line">    super(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat()&#123;</span><br><span class="line">    console.log(&apos;dog eats food&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    console.log(&apos;dog sleeped&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  constructor(...args)&#123;</span><br><span class="line">    super(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat()&#123;</span><br><span class="line">    console.log(&apos;cat eats fish&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    console.log(&apos;cat sleeped&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">let dog = new Dog();</span><br><span class="line">dog.live();</span><br><span class="line"></span><br><span class="line">let cat = new Cat();</span><br><span class="line">cat.live();</span><br></pre></td></tr></table></figure>
<h3 id="十三、状态模式"><a href="#十三、状态模式" class="headerlink" title="十三、状态模式"></a>十三、状态模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 状态模式：对象的行为是基于状态来改变的。</span><br><span class="line"> * 内部的状态转化，导致了行为表现形式不同。所以，用户在外面看来，好像是修改了行为。</span><br><span class="line"> * 优点：封装了转化规则，对于大量分支语句来说，可以考虑使用状态类进一步封装。每个状态都是确定的，所以对象行为是可控的。</span><br><span class="line"> * 缺点：状态模式的关键是将事物的状态都封装成为单独的类，这个类的各种方法就是“此种状态对应的表现行为”。因此，状态类会增加程序开销。</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  FSM 有限状态机</span><br><span class="line">const FSM = (()=&gt;&#123;</span><br><span class="line">  let current_state = &quot;download&quot;;</span><br><span class="line">  return &#123;</span><br><span class="line">    download: &#123;</span><br><span class="line">      click: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;暂停下载&apos;);</span><br><span class="line">        current_state = &apos;pause&apos;;</span><br><span class="line">      &#125;,</span><br><span class="line">      del: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;先暂停，再删除&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    pause: &#123;</span><br><span class="line">      click: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;继续下载&apos;);</span><br><span class="line">        current_state = &apos;download&apos;;</span><br><span class="line">      &#125;,</span><br><span class="line">      del: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;删除任务&apos;);</span><br><span class="line">        current_state = &apos;deleted&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    deleted: &#123;</span><br><span class="line">      click: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;任务已删除，请重新开始&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      del: () =&gt; &#123;</span><br><span class="line">        console.log(&apos;任务已删除&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getState: () =&gt; current_state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">class Download &#123;</span><br><span class="line">  constructor(fsm)&#123;</span><br><span class="line">    this.fsm = fsm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    const &#123; fsm &#125; = this;</span><br><span class="line">    fsm[fsm.getState()].click();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleDel()&#123;</span><br><span class="line">    const &#123;fsm&#125; = this;</span><br><span class="line">    fsm[fsm.getState()].del();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始下载</span><br><span class="line">let download = new Download(FSM);</span><br><span class="line"></span><br><span class="line">download.handleClick(); // 暂停下载</span><br><span class="line">download.handleClick(); // 继续下载</span><br><span class="line">download.handleDel(); // 下载中，无法删除</span><br><span class="line">download.handleClick(); // 暂停下载</span><br><span class="line">download.handleDel(); // 删除任务</span><br><span class="line">download.handleClick(); // 任务已删除，请重新开始</span><br><span class="line">download.handleDel();</span><br></pre></td></tr></table></figure>
<h3 id="十四、策略模式"><a href="#十四、策略模式" class="headerlink" title="十四、策略模式"></a>十四、策略模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 策略模式：能够把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。</span><br><span class="line"> * 策略模式实现的核心就是将算法的使用和算法的实现分离。</span><br><span class="line"> * 算法的实现交给策略类。</span><br><span class="line"> * 算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。</span><br><span class="line"> * 在使用的时候，需要了解所有的策略之间的异同点，才能选择合适的策略进行调用。</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  策略类</span><br><span class="line">const strategies = &#123;</span><br><span class="line">  A()&#123;</span><br><span class="line">    console.log(&apos;This is strategy A&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  B()&#123;</span><br><span class="line">    console.log(&apos;This is strategy B&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 环境类</span><br><span class="line">const context = name =&gt; &#123;</span><br><span class="line">  return strategies[name]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">// 调用策略A，B</span><br><span class="line">context(&apos;A&apos;);</span><br><span class="line">context(&apos;B&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="十五、解释器模式"><a href="#十五、解释器模式" class="headerlink" title="十五、解释器模式"></a>十五、解释器模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解释器模式：提供了评估语言的语法或表达式的方式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Context &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.__list = []; // 存放 终结符表达式</span><br><span class="line">    this.__sum = 0; // </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get sum() &#123;</span><br><span class="line">    return this.__sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set sum(newVale) &#123;</span><br><span class="line">    this.__sum = newVale</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(expression)&#123;</span><br><span class="line">    this.__list.push(expression)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get list()&#123;</span><br><span class="line">    return [...this.__list]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PlusExpression &#123;</span><br><span class="line">  interpret(context) &#123;</span><br><span class="line">    if(!(context instanceof Context))&#123;</span><br><span class="line">      throw new Error(&apos;TypeError&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    context.sum = ++context.sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MinusExpression &#123;</span><br><span class="line">  interpret(context) &#123;</span><br><span class="line">    if(!(context instanceof Context))&#123;</span><br><span class="line">      throw new Error(&apos;TypeError&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    context.sum = --context.sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">const context = new Context();</span><br><span class="line">context.add(new PlusExpression());</span><br><span class="line">context.add(new PlusExpression());</span><br><span class="line">context.add(new MinusExpression());</span><br><span class="line"></span><br><span class="line">context.list.forEach(expression =&gt; &#123;</span><br><span class="line">  expression.interpret(context);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(context.sum);</span><br></pre></td></tr></table></figure>
<h3 id="十六、订阅-发布模式"><a href="#十六、订阅-发布模式" class="headerlink" title="十六、订阅-发布模式"></a>十六、订阅-发布模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 订阅-发布模式：定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都得到了通知。</span><br><span class="line"> * 与观察者模式对比：订阅发布模式中多了一个中间层，一个被抽离出来的信息调度中心。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Event = &#123;</span><br><span class="line">  clientList: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // 绑定事件监听</span><br><span class="line">  listen(key, fn)&#123;</span><br><span class="line">    if(!this.clientList[key])&#123;</span><br><span class="line">      this.clientList[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    this.clientList[key].push(fn);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 触发对应事件</span><br><span class="line">  trigger() &#123;</span><br><span class="line">    const key = Array.prototype.shift.apply(arguments);</span><br><span class="line">    fns = this.clientList[key];</span><br><span class="line"></span><br><span class="line">    if(!fns || fns.length === 0)&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(let fn of fns)&#123;</span><br><span class="line">      fn.apply(null, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 移除相关事件</span><br><span class="line">  remove(key, fn)&#123;</span><br><span class="line">    let fns = this.clientList[key];</span><br><span class="line">    if(!fns || !fn)&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反向遍历移除指定事件函数</span><br><span class="line">    for(let l = fns.length - 1; l &gt;= 0; l--)&#123;</span><br><span class="line">      let _fn = fns[l];</span><br><span class="line">      if(_fn == fn)&#123;</span><br><span class="line">        fns.splice(l,1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 为对象动态安装 发布-订阅 功能</span><br><span class="line">const installEvent = obj =&gt; &#123;</span><br><span class="line">  for (let key in Event)&#123;</span><br><span class="line">    obj[key] = Event[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let salesOffices = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line"></span><br><span class="line">// 绑定自定义事件和回掉函数</span><br><span class="line">salesOffices.listen(</span><br><span class="line">  &apos;event01&apos;,</span><br><span class="line">  (fn1 = price =&gt; &#123;</span><br><span class="line">    console.log(&apos;Price is &apos;,price,&apos;at evnet01&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(</span><br><span class="line">  &apos;event02&apos;,</span><br><span class="line">  (fn2 = price =&gt; &#123;</span><br><span class="line">    console.log(&apos;Price is &apos;,price,&apos;at evnet02&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;event01&apos;,1000);</span><br><span class="line">salesOffices.trigger(&apos;event02&apos;,2000);</span><br><span class="line"></span><br><span class="line">salesOffices.remove(&apos;event01&apos;,fn1)</span><br><span class="line"></span><br><span class="line">console.log(fn1);</span><br><span class="line"></span><br><span class="line">console.log(salesOffices.clientList);</span><br><span class="line">console.log(salesOffices.trigger(&apos;event01&apos;));</span><br></pre></td></tr></table></figure>
<h3 id="十七、责任链模式"><a href="#十七、责任链模式" class="headerlink" title="十七、责任链模式"></a>十七、责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 责任链模式：多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系，这些对象连接成为链式结构，每个节点转发请求，知道有对西那个处理为止。</span><br><span class="line"> * 核心：请求者不必知道是谁的哪个节点处理的请求。如果当前不符合终止条件，那么就把请求转发给下一个节点处理。</span><br><span class="line"> * 优点：可以根据需求变动，任意向责任链中添加，删除节点对象。</span><br><span class="line"> * 没有固定的“开始节点”，可以从任意节点开始。</span><br><span class="line"> * 代价：责任链对大的代价就是每个节点带来的多余消耗。当责任链过长，很多节点只有传递作用，而不是真正的处理逻辑。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> class Handler &#123;</span><br><span class="line">   constructor()&#123;</span><br><span class="line">     this.next = null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setNext(handler)&#123;</span><br><span class="line">     this.next = handler;</span><br><span class="line">     return this;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class LogHandler extends Handler &#123;</span><br><span class="line">   constructor(...props)&#123;</span><br><span class="line">     super(...props);</span><br><span class="line">     this.name = &apos;log&apos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   handler(level, msg)&#123;</span><br><span class="line">     if(level === this.name)&#123;</span><br><span class="line">       console.log(`Log: $&#123;msg&#125;`); </span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">     this.next &amp;&amp; this.next.handler(...arguments)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class WarnHandler extends Handler&#123;</span><br><span class="line">   constructor(...props)&#123;</span><br><span class="line">     super(...props);</span><br><span class="line">     this.name = &apos;warn&apos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   handler(level, msg)&#123;</span><br><span class="line">    if(level === this.name)&#123;</span><br><span class="line">      console.log(`Warn: $&#123;msg&#125;`); </span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    this.next &amp;&amp; this.next.handler(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class ErrorHandler extends Handler&#123;</span><br><span class="line">   constructor(...props)&#123;</span><br><span class="line">     super(...props);</span><br><span class="line">     this.name = &apos;error&apos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   handler(level, msg)&#123;</span><br><span class="line">    if(level === this.name)&#123;</span><br><span class="line">      console.log(`Error: $&#123;msg&#125;`); </span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    this.next &amp;&amp; this.next.handler(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//  test</span><br><span class="line"></span><br><span class="line">let logHandler = new LogHandler();</span><br><span class="line">let warnHandler = new WarnHandler();</span><br><span class="line">let errorHandler = new ErrorHandler();</span><br><span class="line"></span><br><span class="line">// 设置链</span><br><span class="line">logHandler.setNext(</span><br><span class="line">  warnHandler.setNext(</span><br><span class="line">    errorHandler</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">logHandler.handler(&apos;warn&apos;,&apos;some error occur&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="十八、迭代器模式"><a href="#十八、迭代器模式" class="headerlink" title="十八、迭代器模式"></a>十八、迭代器模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 迭代器模式：提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现。</span><br><span class="line"> * 内部迭代器：封装的方法完全接手迭代过程，外部只需要一次调用。</span><br><span class="line"> * 外部迭代器：用户必须显式请求迭代下一代元素。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//  实现一个外部迭代器。</span><br><span class="line">const Iterator = obj =&gt; &#123;</span><br><span class="line">  let current = 0;</span><br><span class="line">  let next = () =&gt; (current += 1);</span><br><span class="line">  let end = () =&gt; current &gt;= obj.length;</span><br><span class="line">  let get = () =&gt; obj[current];</span><br><span class="line"></span><br><span class="line">  return &#123;next,end,get&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIter = Iterator([&apos;hello&apos;,&apos;java&apos;,&apos;script&apos;]);</span><br><span class="line"></span><br><span class="line">while(!myIter.end())&#123;</span><br><span class="line">  console.log(myIter.get());</span><br><span class="line">  myIter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xin-tan.com/" target="_blank" rel="noopener">GodBMW</a></p>

    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : Derek <br>
        
        原文链接 : <a href>http://u.lovemma.cn/passages/JavaScript设计模式/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share" style="margin-top: -2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter">
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async></script>
  

  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/js/">
              #js
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/passages/Vue中Echarts组件获取点击数据/" target="_self">Vue中Echarts组件获取点击数据</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/passages/你不知道的js/" target="_self">你不知道的js</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz",
      appKey: "WaR7nrzhliHj9aVwdQzkdlGd",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz", "WaR7nrzhliHj9aVwdQzkdlGd");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2019, 4, 20).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
